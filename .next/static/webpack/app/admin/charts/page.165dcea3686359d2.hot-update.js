"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/charts/page",{

/***/ "(app-pages-browser)/./lib/formulaEngine.ts":
/*!******************************!*\
  !*** ./lib/formulaEngine.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluateFormula: () => (/* binding */ evaluateFormula),\n/* harmony export */   evaluateFormulasBatch: () => (/* binding */ evaluateFormulasBatch),\n/* harmony export */   extractVariablesFromFormula: () => (/* binding */ extractVariablesFromFormula),\n/* harmony export */   getAvailableVariables: () => (/* binding */ getAvailableVariables),\n/* harmony export */   getVariableExample: () => (/* binding */ getVariableExample),\n/* harmony export */   isValidVariable: () => (/* binding */ isValidVariable),\n/* harmony export */   testFormula: () => (/* binding */ testFormula),\n/* harmony export */   validateFormula: () => (/* binding */ validateFormula)\n/* harmony export */ });\n/* harmony import */ var _chartConfigTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chartConfigTypes */ \"(app-pages-browser)/./lib/chartConfigTypes.ts\");\n// lib/formulaEngine.ts - Formula parsing and safe evaluation engine\n// Handles 42 dynamic variables with +, -, *, /, (), and math functions (MAX, MIN, ROUND, ABS)\n// Returns 'NA' for division by zero, missing variables, or invalid expressions\n\n/**\n * Variable mapping from display names to project stats field names\n * Maps [INDOOR] to stats.indoor, [FEMALE] to stats.female, etc.\n */ const VARIABLE_MAPPINGS = {\n    // Image Statistics\n    'REMOTE_IMAGES': 'remoteImages',\n    'HOSTESS_IMAGES': 'hostessImages',\n    'SELFIES': 'selfies',\n    'APPROVED_IMAGES': 'approvedImages',\n    'REJECTED_IMAGES': 'rejectedImages',\n    // Location Statistics\n    'INDOOR': 'indoor',\n    'OUTDOOR': 'outdoor',\n    'STADIUM': 'stadium',\n    // Demographics\n    'FEMALE': 'female',\n    'MALE': 'male',\n    'GEN_ALPHA': 'genAlpha',\n    'GEN_YZ': 'genYZ',\n    'GEN_X': 'genX',\n    'BOOMER': 'boomer',\n    // Merchandise\n    'MERCHED': 'merched',\n    'JERSEY': 'jersey',\n    'SCARF': 'scarf',\n    'FLAGS': 'flags',\n    'BASEBALL_CAP': 'baseballCap',\n    'OTHER': 'other',\n    // Visits & Engagement\n    'VISIT_QR_CODE': 'visitQrCode',\n    'VISIT_SHORT_URL': 'visitShortUrl',\n    'VISIT_WEB': 'visitWeb',\n    'VISIT_FACEBOOK': 'visitFacebook',\n    'VISIT_INSTAGRAM': 'visitInstagram',\n    'VISIT_YOUTUBE': 'visitYoutube',\n    'VISIT_TIKTOK': 'visitTiktok',\n    'VISIT_X': 'visitX',\n    'VISIT_TRUSTPILOT': 'visitTrustpilot',\n    // Event Metrics\n    'EVENT_ATTENDEES': 'eventAttendees',\n    'EVENT_TICKET_PURCHASES': 'eventTicketPurchases',\n    'EVENT_RESULT_HOME': 'eventResultHome',\n    'EVENT_RESULT_VISITOR': 'eventResultVisitor',\n    'EVENT_VALUE_PROPOSITION_VISITED': 'eventValuePropositionVisited',\n    'EVENT_VALUE_PROPOSITION_PURCHASES': 'eventValuePropositionPurchases',\n    // Merchandise Pricing Variables (configurable values for sales calculations)\n    'JERSEY_PRICE': 'jerseyPrice',\n    'SCARF_PRICE': 'scarfPrice',\n    'FLAGS_PRICE': 'flagsPrice',\n    'CAP_PRICE': 'capPrice',\n    'OTHER_PRICE': 'otherPrice'\n};\n/**\n * Safe mathematical functions that can be used in formulas\n * All functions handle edge cases and return 'NA' for invalid inputs\n */ const MATH_FUNCTIONS = {\n    /**\n   * Returns the maximum value from the provided arguments\n   * Example: MAX(10, 20, 5) returns 20\n   */ MAX: (...args)=>{\n        if (args.length === 0) return 'NA';\n        const validArgs = args.filter((arg)=>typeof arg === 'number' && !isNaN(arg));\n        if (validArgs.length === 0) return 'NA';\n        return Math.max(...validArgs);\n    },\n    /**\n   * Returns the minimum value from the provided arguments  \n   * Example: MIN(10, 20, 5) returns 5\n   */ MIN: (...args)=>{\n        if (args.length === 0) return 'NA';\n        const validArgs = args.filter((arg)=>typeof arg === 'number' && !isNaN(arg));\n        if (validArgs.length === 0) return 'NA';\n        return Math.min(...validArgs);\n    },\n    /**\n   * Rounds a number to the nearest integer\n   * Example: ROUND(10.7) returns 11\n   */ ROUND: (value)=>{\n        if (typeof value !== 'number' || isNaN(value)) return 'NA';\n        return Math.round(value);\n    },\n    /**\n   * Returns the absolute value of a number\n   * Example: ABS(-10) returns 10\n   */ ABS: (value)=>{\n        if (typeof value !== 'number' || isNaN(value)) return 'NA';\n        return Math.abs(value);\n    }\n};\n/**\n * Extracts all variable names used in a formula\n * Variables are identified by the pattern [VARIABLE_NAME]\n * @param formula - The formula string to analyze\n * @returns Array of variable names found in the formula\n */ function extractVariablesFromFormula(formula) {\n    const variableRegex = /\\[([A-Z_]+)\\]/g;\n    const variables = [];\n    let match;\n    while((match = variableRegex.exec(formula)) !== null){\n        const variableName = match[1];\n        if (!variables.includes(variableName)) {\n            variables.push(variableName);\n        }\n    }\n    return variables;\n}\n/**\n * Validates a formula for syntax correctness and variable existence\n * Checks for balanced parentheses, valid variables, and safe mathematical operations\n * @param formula - The formula string to validate\n * @returns Validation result with error details if invalid\n */ function validateFormula(formula) {\n    try {\n        // Extract variables from formula\n        const usedVariables = extractVariablesFromFormula(formula);\n        // Check if all variables are valid\n        const invalidVariables = usedVariables.filter((variable)=>!VARIABLE_MAPPINGS.hasOwnProperty(variable));\n        if (invalidVariables.length > 0) {\n            return {\n                isValid: false,\n                error: `Invalid variables: ${invalidVariables.join(', ')}`,\n                usedVariables\n            };\n        }\n        // Check for balanced parentheses\n        let openParens = 0;\n        for (const char of formula){\n            if (char === '(') openParens++;\n            if (char === ')') openParens--;\n            if (openParens < 0) {\n                return {\n                    isValid: false,\n                    error: 'Unbalanced parentheses: closing parenthesis without opening',\n                    usedVariables\n                };\n            }\n        }\n        if (openParens > 0) {\n            return {\n                isValid: false,\n                error: 'Unbalanced parentheses: unclosed opening parenthesis',\n                usedVariables\n            };\n        }\n        // Test evaluation with sample data (all variables set to 1)\n        const testStats = Object.fromEntries(Object.values(VARIABLE_MAPPINGS).map((field)=>[\n                field,\n                1\n            ]));\n        const testResult = evaluateFormula(formula, testStats);\n        return {\n            isValid: true,\n            usedVariables,\n            evaluatedResult: testResult\n        };\n    } catch (error) {\n        return {\n            isValid: false,\n            error: error instanceof Error ? error.message : 'Formula validation failed',\n            usedVariables: []\n        };\n    }\n}\n/**\n * Substitutes variables in a formula with their actual values from project stats\n * Replaces [VARIABLE_NAME] with the corresponding numeric value\n * @param formula - The formula string with variables\n * @param stats - Project statistics containing actual values\n * @returns Formula string with variables replaced by numbers\n */ function substituteVariables(formula, stats) {\n    let processedFormula = formula;\n    // Replace all variables with their actual values\n    for (const [variableName, fieldName] of Object.entries(VARIABLE_MAPPINGS)){\n        const variablePattern = new RegExp(`\\\\[${variableName}\\\\]`, 'g');\n        const value = stats[fieldName];\n        // Handle missing or undefined values\n        const actualValue = value !== undefined && value !== null ? value : 0;\n        processedFormula = processedFormula.replace(variablePattern, actualValue.toString());\n    }\n    return processedFormula;\n}\n/**\n * Processes mathematical functions in a formula string\n * Replaces function calls like MAX(1,2,3) with their evaluated results\n * @param formula - Formula string potentially containing function calls\n * @returns Formula string with functions evaluated\n */ function processMathFunctions(formula) {\n    let processedFormula = formula;\n    // Process each available math function\n    for (const [functionName, functionImpl] of Object.entries(MATH_FUNCTIONS)){\n        const functionRegex = new RegExp(`${functionName}\\\\(([^)]+)\\\\)`, 'g');\n        processedFormula = processedFormula.replace(functionRegex, (match, argsString)=>{\n            try {\n                // Parse arguments (handle nested expressions by evaluating them first)\n                const args = argsString.split(',').map((arg)=>{\n                    const trimmedArg = arg.trim();\n                    // If argument contains operators, evaluate it first\n                    if (/[+\\-*/()]/.test(trimmedArg)) {\n                        const argResult = evaluateSimpleExpression(trimmedArg);\n                        return typeof argResult === 'number' ? argResult : 0;\n                    }\n                    return parseFloat(trimmedArg);\n                });\n                // Call the function with parsed arguments\n                const result = functionImpl(...args);\n                return result === 'NA' ? 'NaN' : result.toString();\n            } catch (error) {\n                return 'NaN'; // Return NaN for any function evaluation errors\n            }\n        });\n    }\n    return processedFormula;\n}\n/**\n * Safely evaluates a simple mathematical expression\n * Handles basic arithmetic operations with division by zero protection\n * @param expression - Mathematical expression to evaluate\n * @returns Numeric result or 'NA' for errors\n */ function evaluateSimpleExpression(expression) {\n    try {\n        // Remove whitespace\n        const cleanExpression = expression.replace(/\\s+/g, '');\n        // Check for division by zero\n        if (/\\/\\s*0(?!\\d)/.test(cleanExpression)) {\n            return 'NA';\n        }\n        // Use Function constructor for safe evaluation (more secure than eval)\n        // This only allows mathematical operations, no access to global scope\n        const safeEval = new Function('return ' + cleanExpression);\n        const result = safeEval();\n        // Check for invalid results\n        if (typeof result !== 'number' || isNaN(result) || !isFinite(result)) {\n            return 'NA';\n        }\n        return result;\n    } catch (error) {\n        return 'NA';\n    }\n}\n/**\n * Main function to evaluate a formula against project statistics\n * Handles variable substitution, function processing, and safe evaluation\n * @param formula - The formula string to evaluate\n * @param stats - Project statistics for variable values\n * @returns Numeric result or 'NA' for errors/invalid results\n */ function evaluateFormula(formula, stats) {\n    try {\n        // Step 1: Substitute variables with actual values\n        const formulaWithValues = substituteVariables(formula, stats);\n        // Step 2: Process mathematical functions\n        const formulaWithFunctions = processMathFunctions(formulaWithValues);\n        // Step 3: Evaluate the final mathematical expression\n        const result = evaluateSimpleExpression(formulaWithFunctions);\n        return result;\n    } catch (error) {\n        console.error('Formula evaluation error:', error);\n        return 'NA';\n    }\n}\n/**\n * Batch evaluates multiple formulas against the same project statistics\n * More efficient than calling evaluateFormula multiple times\n * @param formulas - Array of formula strings to evaluate\n * @param stats - Project statistics for variable values  \n * @returns Array of results corresponding to input formulas\n */ function evaluateFormulasBatch(formulas, stats) {\n    return formulas.map((formula)=>evaluateFormula(formula, stats));\n}\n/**\n * Gets all available variables with their descriptions\n * Useful for building variable picker UIs\n * @returns Array of available variables with metadata\n */ function getAvailableVariables() {\n    return _chartConfigTypes__WEBPACK_IMPORTED_MODULE_0__.AVAILABLE_VARIABLES;\n}\n/**\n * Checks if a specific variable exists and is valid\n * @param variableName - Name of variable to check (e.g., \"INDOOR\", \"FEMALE\")\n * @returns Boolean indicating if variable is valid\n */ function isValidVariable(variableName) {\n    return VARIABLE_MAPPINGS.hasOwnProperty(variableName);\n}\n/**\n * Gets example usage for a specific variable\n * @param variableName - Name of variable to get example for\n * @returns Example formula using the variable, or null if variable is invalid\n */ function getVariableExample(variableName) {\n    const variable = _chartConfigTypes__WEBPACK_IMPORTED_MODULE_0__.AVAILABLE_VARIABLES.find((v)=>v.name === variableName);\n    return variable ? variable.exampleUsage : null;\n}\n/**\n * Test utility function for development and debugging\n * Evaluates a formula against sample test data\n * @param formula - Formula to test\n * @returns Test result with sample data\n */ function testFormula(formula) {\n    const sampleData = {\n        remoteImages: 10,\n        hostessImages: 25,\n        selfies: 15,\n        indoor: 50,\n        outdoor: 30,\n        stadium: 200,\n        female: 120,\n        male: 160,\n        genAlpha: 20,\n        genYZ: 100,\n        genX: 80,\n        boomer: 80,\n        merched: 40,\n        jersey: 15,\n        scarf: 8,\n        flags: 12,\n        baseballCap: 5,\n        other: 3,\n        approvedImages: 45,\n        rejectedImages: 5,\n        visitQrCode: 30,\n        visitShortUrl: 20,\n        visitWeb: 100,\n        visitFacebook: 25,\n        visitInstagram: 40,\n        visitYoutube: 15,\n        visitTiktok: 35,\n        visitX: 10,\n        visitTrustpilot: 5,\n        eventAttendees: 1000,\n        eventTicketPurchases: 850,\n        eventResultHome: 2,\n        eventResultVisitor: 1,\n        eventValuePropositionVisited: 75,\n        eventValuePropositionPurchases: 12\n    };\n    const result = evaluateFormula(formula, sampleData);\n    return {\n        result,\n        sampleData\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9mb3JtdWxhRW5naW5lLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRTtBQUNwRSw4RkFBOEY7QUFDOUYsK0VBQStFO0FBRUc7QUFFbEY7OztDQUdDLEdBQ0QsTUFBTUMsb0JBQTRDO0lBQ2hELG1CQUFtQjtJQUNuQixpQkFBaUI7SUFDakIsa0JBQWtCO0lBQ2xCLFdBQVc7SUFDWCxtQkFBbUI7SUFDbkIsbUJBQW1CO0lBRW5CLHNCQUFzQjtJQUN0QixVQUFVO0lBQ1YsV0FBVztJQUNYLFdBQVc7SUFFWCxlQUFlO0lBQ2YsVUFBVTtJQUNWLFFBQVE7SUFDUixhQUFhO0lBQ2IsVUFBVTtJQUNWLFNBQVM7SUFDVCxVQUFVO0lBRVYsY0FBYztJQUNkLFdBQVc7SUFDWCxVQUFVO0lBQ1YsU0FBUztJQUNULFNBQVM7SUFDVCxnQkFBZ0I7SUFDaEIsU0FBUztJQUVULHNCQUFzQjtJQUN0QixpQkFBaUI7SUFDakIsbUJBQW1CO0lBQ25CLGFBQWE7SUFDYixrQkFBa0I7SUFDbEIsbUJBQW1CO0lBQ25CLGlCQUFpQjtJQUNqQixnQkFBZ0I7SUFDaEIsV0FBVztJQUNYLG9CQUFvQjtJQUVwQixnQkFBZ0I7SUFDaEIsbUJBQW1CO0lBQ25CLDBCQUEwQjtJQUMxQixxQkFBcUI7SUFDckIsd0JBQXdCO0lBQ3hCLG1DQUFtQztJQUNuQyxxQ0FBcUM7SUFFckMsNkVBQTZFO0lBQzdFLGdCQUFnQjtJQUNoQixlQUFlO0lBQ2YsZUFBZTtJQUNmLGFBQWE7SUFDYixlQUFlO0FBQ2pCO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUMsaUJBQWlCO0lBQ3JCOzs7R0FHQyxHQUNEQyxLQUFLLENBQUMsR0FBR0M7UUFDUCxJQUFJQSxLQUFLQyxNQUFNLEtBQUssR0FBRyxPQUFPO1FBQzlCLE1BQU1DLFlBQVlGLEtBQUtHLE1BQU0sQ0FBQ0MsQ0FBQUEsTUFBTyxPQUFPQSxRQUFRLFlBQVksQ0FBQ0MsTUFBTUQ7UUFDdkUsSUFBSUYs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T0FBT3hCLGtCQUFrQitCLGNBQWMsQ0FBQ1A7QUFDMUM7QUFFQTs7OztDQUlDLEdBQ00sU0FBUzRELG1CQUFtQjVELFlBQW9CO0lBQ3JELE1BQU1NLFdBQVcvQixrRUFBbUJBLENBQUNzRixJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUksS0FBSy9EO0lBQzFELE9BQU9NLFdBQVdBLFNBQVMwRCxZQUFZLEdBQUc7QUFDNUM7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNDLFlBQVl0RSxPQUFlO0lBQ3pDLE1BQU11RSxhQUEyQjtRQUMvQkMsY0FBYztRQUFJQyxlQUFlO1FBQUlDLFNBQVM7UUFDOUNDLFFBQVE7UUFBSUMsU0FBUztRQUFJQyxTQUFTO1FBQ2xDQyxRQUFRO1FBQUtDLE1BQU07UUFDbkJDLFVBQVU7UUFBSUMsT0FBTztRQUFLQyxNQUFNO1FBQUlDLFFBQVE7UUFDNUNDLFNBQVM7UUFBSUMsUUFBUTtRQUFJQyxPQUFPO1FBQUdDLE9BQU87UUFBSUMsYUFBYTtRQUFHQyxPQUFPO1FBQ3JFQyxnQkFBZ0I7UUFBSUMsZ0JBQWdCO1FBQ3BDQyxhQUFhO1FBQUlDLGVBQWU7UUFBSUMsVUFBVTtRQUM5Q0MsZUFBZTtRQUFJQyxnQkFBZ0I7UUFBSUMsY0FBYztRQUNyREMsYUFBYTtRQUFJQyxRQUFRO1FBQUlDLGlCQUFpQjtRQUM5Q0MsZ0JBQWdCO1FBQU1DLHNCQUFzQjtRQUM1Q0MsaUJBQWlCO1FBQUdDLG9CQUFvQjtRQUN4Q0MsOEJBQThCO1FBQUlDLGdDQUFnQztJQUNwRTtJQUVBLE1BQU10RCxTQUFTM0IsZ0JBQWdCekIsU0FBU3VFO0lBQ3hDLE9BQU87UUFBRW5CO1FBQVFtQjtJQUFXO0FBQzlCIiwic291cmNlcyI6WyIvVXNlcnMvbW9sZG92YW4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL2NvbX5hcHBsZX5DbG91ZERvY3MvUHJvamVjdHMvbWVzc21hc3MvbGliL2Zvcm11bGFFbmdpbmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL2Zvcm11bGFFbmdpbmUudHMgLSBGb3JtdWxhIHBhcnNpbmcgYW5kIHNhZmUgZXZhbHVhdGlvbiBlbmdpbmVcbi8vIEhhbmRsZXMgNDIgZHluYW1pYyB2YXJpYWJsZXMgd2l0aCArLCAtLCAqLCAvLCAoKSwgYW5kIG1hdGggZnVuY3Rpb25zIChNQVgsIE1JTiwgUk9VTkQsIEFCUylcbi8vIFJldHVybnMgJ05BJyBmb3IgZGl2aXNpb24gYnkgemVybywgbWlzc2luZyB2YXJpYWJsZXMsIG9yIGludmFsaWQgZXhwcmVzc2lvbnNcblxuaW1wb3J0IHsgQVZBSUxBQkxFX1ZBUklBQkxFUywgRm9ybXVsYVZhbGlkYXRpb25SZXN1bHQgfSBmcm9tICcuL2NoYXJ0Q29uZmlnVHlwZXMnO1xuXG4vKipcbiAqIFZhcmlhYmxlIG1hcHBpbmcgZnJvbSBkaXNwbGF5IG5hbWVzIHRvIHByb2plY3Qgc3RhdHMgZmllbGQgbmFtZXNcbiAqIE1hcHMgW0lORE9PUl0gdG8gc3RhdHMuaW5kb29yLCBbRkVNQUxFXSB0byBzdGF0cy5mZW1hbGUsIGV0Yy5cbiAqL1xuY29uc3QgVkFSSUFCTEVfTUFQUElOR1M6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIC8vIEltYWdlIFN0YXRpc3RpY3NcbiAgJ1JFTU9URV9JTUFHRVMnOiAncmVtb3RlSW1hZ2VzJyxcbiAgJ0hPU1RFU1NfSU1BR0VTJzogJ2hvc3Rlc3NJbWFnZXMnLFxuICAnU0VMRklFUyc6ICdzZWxmaWVzJyxcbiAgJ0FQUFJPVkVEX0lNQUdFUyc6ICdhcHByb3ZlZEltYWdlcycsXG4gICdSRUpFQ1RFRF9JTUFHRVMnOiAncmVqZWN0ZWRJbWFnZXMnLFxuICBcbiAgLy8gTG9jYXRpb24gU3RhdGlzdGljc1xuICAnSU5ET09SJzogJ2luZG9vcicsXG4gICdPVVRET09SJzogJ291dGRvb3InLFxuICAnU1RBRElVTSc6ICdzdGFkaXVtJyxcbiAgXG4gIC8vIERlbW9ncmFwaGljc1xuICAnRkVNQUxFJzogJ2ZlbWFsZScsXG4gICdNQUxFJzogJ21hbGUnLFxuICAnR0VOX0FMUEhBJzogJ2dlbkFscGhhJyxcbiAgJ0dFTl9ZWic6ICdnZW5ZWicsXG4gICdHRU5fWCc6ICdnZW5YJyxcbiAgJ0JPT01FUic6ICdib29tZXInLFxuICBcbiAgLy8gTWVyY2hhbmRpc2VcbiAgJ01FUkNIRUQnOiAnbWVyY2hlZCcsXG4gICdKRVJTRVknOiAnamVyc2V5JyxcbiAgJ1NDQVJGJzogJ3NjYXJmJyxcbiAgJ0ZMQUdTJzogJ2ZsYWdzJyxcbiAgJ0JBU0VCQUxMX0NBUCc6ICdiYXNlYmFsbENhcCcsXG4gICdPVEhFUic6ICdvdGhlcicsXG4gIFxuICAvLyBWaXNpdHMgJiBFbmdhZ2VtZW50XG4gICdWSVNJVF9RUl9DT0RFJzogJ3Zpc2l0UXJDb2RlJyxcbiAgJ1ZJU0lUX1NIT1JUX1VSTCc6ICd2aXNpdFNob3J0VXJsJyxcbiAgJ1ZJU0lUX1dFQic6ICd2aXNpdFdlYicsXG4gICdWSVNJVF9GQUNFQk9PSyc6ICd2aXNpdEZhY2Vib29rJyxcbiAgJ1ZJU0lUX0lOU1RBR1JBTSc6ICd2aXNpdEluc3RhZ3JhbScsXG4gICdWSVNJVF9ZT1VUVUJFJzogJ3Zpc2l0WW91dHViZScsXG4gICdWSVNJVF9USUtUT0snOiAndmlzaXRUaWt0b2snLFxuICAnVklTSVRfWCc6ICd2aXNpdFgnLFxuICAnVklTSVRfVFJVU1RQSUxPVCc6ICd2aXNpdFRydXN0cGlsb3QnLFxuICBcbiAgLy8gRXZlbnQgTWV0cmljc1xuICAnRVZFTlRfQVRURU5ERUVTJzogJ2V2ZW50QXR0ZW5kZWVzJyxcbiAgJ0VWRU5UX1RJQ0tFVF9QVVJDSEFTRVMnOiAnZXZlbnRUaWNrZXRQdXJjaGFzZXMnLFxuICAnRVZFTlRfUkVTVUxUX0hPTUUnOiAnZXZlbnRSZXN1bHRIb21lJyxcbiAgJ0VWRU5UX1JFU1VMVF9WSVNJVE9SJzogJ2V2ZW50UmVzdWx0VmlzaXRvcicsXG4gICdFVkVOVF9WQUxVRV9QUk9QT1NJVElPTl9WSVNJVEVEJzogJ2V2ZW50VmFsdWVQcm9wb3NpdGlvblZpc2l0ZWQnLFxuICAnRVZFTlRfVkFMVUVfUFJPUE9TSVRJT05fUFVSQ0hBU0VTJzogJ2V2ZW50VmFsdWVQcm9wb3NpdGlvblB1cmNoYXNlcycsXG4gIFxuICAvLyBNZXJjaGFuZGlzZSBQcmljaW5nIFZhcmlhYmxlcyAoY29uZmlndXJhYmxlIHZhbHVlcyBmb3Igc2FsZXMgY2FsY3VsYXRpb25zKVxuICAnSkVSU0VZX1BSSUNFJzogJ2plcnNleVByaWNlJyxcbiAgJ1NDQVJGX1BSSUNFJzogJ3NjYXJmUHJpY2UnLFxuICAnRkxBR1NfUFJJQ0UnOiAnZmxhZ3NQcmljZScsXG4gICdDQVBfUFJJQ0UnOiAnY2FwUHJpY2UnLFxuICAnT1RIRVJfUFJJQ0UnOiAnb3RoZXJQcmljZSdcbn07XG5cbi8qKlxuICogU2FmZSBtYXRoZW1hdGljYWwgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gZm9ybXVsYXNcbiAqIEFsbCBmdW5jdGlvbnMgaGFuZGxlIGVkZ2UgY2FzZXMgYW5kIHJldHVybiAnTkEnIGZvciBpbnZhbGlkIGlucHV0c1xuICovXG5jb25zdCBNQVRIX0ZVTkNUSU9OUyA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgZnJvbSB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gICAqIEV4YW1wbGU6IE1BWCgxMCwgMjAsIDUpIHJldHVybnMgMjBcbiAgICovXG4gIE1BWDogKC4uLmFyZ3M6IG51bWJlcltdKTogbnVtYmVyIHwgJ05BJyA9PiB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gJ05BJztcbiAgICBjb25zdCB2YWxpZEFyZ3MgPSBhcmdzLmZpbHRlcihhcmcgPT4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGFyZykpO1xuICAgIGlmICh2YWxpZEFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gJ05BJztcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4udmFsaWRBcmdzKTtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIGZyb20gdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyAgXG4gICAqIEV4YW1wbGU6IE1JTigxMCwgMjAsIDUpIHJldHVybnMgNVxuICAgKi9cbiAgTUlOOiAoLi4uYXJnczogbnVtYmVyW10pOiBudW1iZXIgfCAnTkEnID0+IHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiAnTkEnO1xuICAgIGNvbnN0IHZhbGlkQXJncyA9IGFyZ3MuZmlsdGVyKGFyZyA9PiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oYXJnKSk7XG4gICAgaWYgKHZhbGlkQXJncy5sZW5ndGggPT09IDApIHJldHVybiAnTkEnO1xuICAgIHJldHVybiBNYXRoLm1pbiguLi52YWxpZEFyZ3MpO1xuICB9LFxuICBcbiAgLyoqXG4gICAqIFJvdW5kcyBhIG51bWJlciB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyXG4gICAqIEV4YW1wbGU6IFJPVU5EKDEwLjcpIHJldHVybnMgMTFcbiAgICovXG4gIFJPVU5EOiAodmFsdWU6IG51bWJlcik6IG51bWJlciB8ICdOQScgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IGlzTmFOKHZhbHVlKSkgcmV0dXJuICdOQSc7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICB9LFxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGEgbnVtYmVyXG4gICAqIEV4YW1wbGU6IEFCUygtMTApIHJldHVybnMgMTBcbiAgICovXG4gIEFCUzogKHZhbHVlOiBudW1iZXIpOiBudW1iZXIgfCAnTkEnID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCBpc05hTih2YWx1ZSkpIHJldHVybiAnTkEnO1xuICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvamVjdCBzdGF0aXN0aWNzIGludGVyZmFjZSBtYXRjaGluZyB0aGUgZXhpc3Rpbmcgc3RydWN0dXJlXG4gKiBVc2VkIGZvciB0eXBlIGNoZWNraW5nIHdoZW4gZXZhbHVhdGluZyBmb3JtdWxhcyBhZ2FpbnN0IHJlYWwgZGF0YVxuICovXG5pbnRlcmZhY2UgUHJvamVjdFN0YXRzIHtcbiAgcmVtb3RlSW1hZ2VzOiBudW1iZXI7XG4gIGhvc3Rlc3NJbWFnZXM6IG51bWJlcjtcbiAgc2VsZmllczogbnVtYmVyO1xuICBpbmRvb3I6IG51bWJlcjtcbiAgb3V0ZG9vcjogbnVtYmVyO1xuICBzdGFkaXVtOiBudW1iZXI7XG4gIGZlbWFsZTogbnVtYmVyO1xuICBtYWxlOiBudW1iZXI7XG4gIGdlbkFscGhhOiBudW1iZXI7XG4gIGdlbllaOiBudW1iZXI7XG4gIGdlblg6IG51bWJlcjtcbiAgYm9vbWVyOiBudW1iZXI7XG4gIG1lcmNoZWQ6IG51bWJlcjtcbiAgamVyc2V5OiBudW1iZXI7XG4gIHNjYXJmOiBudW1iZXI7XG4gIGZsYWdzOiBudW1iZXI7XG4gIGJhc2ViYWxsQ2FwOiBudW1iZXI7XG4gIG90aGVyOiBudW1iZXI7XG4gIC8vIE9wdGlvbmFsIFN1Y2Nlc3MgTWFuYWdlciBmaWVsZHNcbiAgYXBwcm92ZWRJbWFnZXM/OiBudW1iZXI7XG4gIHJlamVjdGVkSW1hZ2VzPzogbnVtYmVyO1xuICB2aXNpdFFyQ29kZT86IG51bWJlcjtcbiAgdmlzaXRTaG9ydFVybD86IG51bWJlcjtcbiAgdmlzaXRXZWI/OiBudW1iZXI7XG4gIHZpc2l0RmFjZWJvb2s/OiBudW1iZXI7XG4gIHZpc2l0SW5zdGFncmFtPzogbnVtYmVyO1xuICB2aXNpdFlvdXR1YmU/OiBudW1iZXI7XG4gIHZpc2l0VGlrdG9rPzogbnVtYmVyO1xuICB2aXNpdFg/OiBudW1iZXI7XG4gIHZpc2l0VHJ1c3RwaWxvdD86IG51bWJlcjtcbiAgZXZlbnRBdHRlbmRlZXM/OiBudW1iZXI7XG4gIGV2ZW50VGlja2V0UHVyY2hhc2VzPzogbnVtYmVyO1xuICBldmVudFJlc3VsdEhvbWU/OiBudW1iZXI7XG4gIGV2ZW50UmVzdWx0VmlzaXRvcj86IG51bWJlcjtcbiAgZXZlbnRWYWx1ZVByb3Bvc2l0aW9uVmlzaXRlZD86IG51bWJlcjtcbiAgZXZlbnRWYWx1ZVByb3Bvc2l0aW9uUHVyY2hhc2VzPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFsbCB2YXJpYWJsZSBuYW1lcyB1c2VkIGluIGEgZm9ybXVsYVxuICogVmFyaWFibGVzIGFyZSBpZGVudGlmaWVkIGJ5IHRoZSBwYXR0ZXJuIFtWQVJJQUJMRV9OQU1FXVxuICogQHBhcmFtIGZvcm11bGEgLSBUaGUgZm9ybXVsYSBzdHJpbmcgdG8gYW5hbHl6ZVxuICogQHJldHVybnMgQXJyYXkgb2YgdmFyaWFibGUgbmFtZXMgZm91bmQgaW4gdGhlIGZvcm11bGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RWYXJpYWJsZXNGcm9tRm9ybXVsYShmb3JtdWxhOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHZhcmlhYmxlUmVnZXggPSAvXFxbKFtBLVpfXSspXFxdL2c7XG4gIGNvbnN0IHZhcmlhYmxlczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IG1hdGNoO1xuICBcbiAgd2hpbGUgKChtYXRjaCA9IHZhcmlhYmxlUmVnZXguZXhlYyhmb3JtdWxhKSkgIT09IG51bGwpIHtcbiAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBtYXRjaFsxXTtcbiAgICBpZiAoIXZhcmlhYmxlcy5pbmNsdWRlcyh2YXJpYWJsZU5hbWUpKSB7XG4gICAgICB2YXJpYWJsZXMucHVzaCh2YXJpYWJsZU5hbWUpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHZhcmlhYmxlcztcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBmb3JtdWxhIGZvciBzeW50YXggY29ycmVjdG5lc3MgYW5kIHZhcmlhYmxlIGV4aXN0ZW5jZVxuICogQ2hlY2tzIGZvciBiYWxhbmNlZCBwYXJlbnRoZXNlcywgdmFsaWQgdmFyaWFibGVzLCBhbmQgc2FmZSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uc1xuICogQHBhcmFtIGZvcm11bGEgLSBUaGUgZm9ybXVsYSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIFZhbGlkYXRpb24gcmVzdWx0IHdpdGggZXJyb3IgZGV0YWlscyBpZiBpbnZhbGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZvcm11bGEoZm9ybXVsYTogc3RyaW5nKTogRm9ybXVsYVZhbGlkYXRpb25SZXN1bHQge1xuICB0cnkge1xuICAgIC8vIEV4dHJhY3QgdmFyaWFibGVzIGZyb20gZm9ybXVsYVxuICAgIGNvbnN0IHVzZWRWYXJpYWJsZXMgPSBleHRyYWN0VmFyaWFibGVzRnJvbUZvcm11bGEoZm9ybXVsYSk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYWxsIHZhcmlhYmxlcyBhcmUgdmFsaWRcbiAgICBjb25zdCBpbnZhbGlkVmFyaWFibGVzID0gdXNlZFZhcmlhYmxlcy5maWx0ZXIoXG4gICAgICB2YXJpYWJsZSA9PiAhVkFSSUFCTEVfTUFQUElOR1MuaGFzT3duUHJvcGVydHkodmFyaWFibGUpXG4gICAgKTtcbiAgICBcbiAgICBpZiAoaW52YWxpZFZhcmlhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBJbnZhbGlkIHZhcmlhYmxlczogJHtpbnZhbGlkVmFyaWFibGVzLmpvaW4oJywgJyl9YCxcbiAgICAgICAgdXNlZFZhcmlhYmxlc1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGJhbGFuY2VkIHBhcmVudGhlc2VzXG4gICAgbGV0IG9wZW5QYXJlbnMgPSAwO1xuICAgIGZvciAoY29uc3QgY2hhciBvZiBmb3JtdWxhKSB7XG4gICAgICBpZiAoY2hhciA9PT0gJygnKSBvcGVuUGFyZW5zKys7XG4gICAgICBpZiAoY2hhciA9PT0gJyknKSBvcGVuUGFyZW5zLS07XG4gICAgICBpZiAob3BlblBhcmVucyA8IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ1VuYmFsYW5jZWQgcGFyZW50aGVzZXM6IGNsb3NpbmcgcGFyZW50aGVzaXMgd2l0aG91dCBvcGVuaW5nJyxcbiAgICAgICAgICB1c2VkVmFyaWFibGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChvcGVuUGFyZW5zID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnVW5iYWxhbmNlZCBwYXJlbnRoZXNlczogdW5jbG9zZWQgb3BlbmluZyBwYXJlbnRoZXNpcycsXG4gICAgICAgIHVzZWRWYXJpYWJsZXNcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFRlc3QgZXZhbHVhdGlvbiB3aXRoIHNhbXBsZSBkYXRhIChhbGwgdmFyaWFibGVzIHNldCB0byAxKVxuICAgIGNvbnN0IHRlc3RTdGF0cyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC52YWx1ZXMoVkFSSUFCTEVfTUFQUElOR1MpLm1hcChmaWVsZCA9PiBbZmllbGQsIDFdKVxuICAgICkgYXMgUHJvamVjdFN0YXRzO1xuICAgIFxuICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBldmFsdWF0ZUZvcm11bGEoZm9ybXVsYSwgdGVzdFN0YXRzKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgIHVzZWRWYXJpYWJsZXMsXG4gICAgICBldmFsdWF0ZWRSZXN1bHQ6IHRlc3RSZXN1bHRcbiAgICB9O1xuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGb3JtdWxhIHZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgIHVzZWRWYXJpYWJsZXM6IFtdXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFN1YnN0aXR1dGVzIHZhcmlhYmxlcyBpbiBhIGZvcm11bGEgd2l0aCB0aGVpciBhY3R1YWwgdmFsdWVzIGZyb20gcHJvamVjdCBzdGF0c1xuICogUmVwbGFjZXMgW1ZBUklBQkxFX05BTUVdIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgbnVtZXJpYyB2YWx1ZVxuICogQHBhcmFtIGZvcm11bGEgLSBUaGUgZm9ybXVsYSBzdHJpbmcgd2l0aCB2YXJpYWJsZXNcbiAqIEBwYXJhbSBzdGF0cyAtIFByb2plY3Qgc3RhdGlzdGljcyBjb250YWluaW5nIGFjdHVhbCB2YWx1ZXNcbiAqIEByZXR1cm5zIEZvcm11bGEgc3RyaW5nIHdpdGggdmFyaWFibGVzIHJlcGxhY2VkIGJ5IG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gc3Vic3RpdHV0ZVZhcmlhYmxlcyhmb3JtdWxhOiBzdHJpbmcsIHN0YXRzOiBQcm9qZWN0U3RhdHMpOiBzdHJpbmcge1xuICBsZXQgcHJvY2Vzc2VkRm9ybXVsYSA9IGZvcm11bGE7XG4gIFxuICAvLyBSZXBsYWNlIGFsbCB2YXJpYWJsZXMgd2l0aCB0aGVpciBhY3R1YWwgdmFsdWVzXG4gIGZvciAoY29uc3QgW3ZhcmlhYmxlTmFtZSwgZmllbGROYW1lXSBvZiBPYmplY3QuZW50cmllcyhWQVJJQUJMRV9NQVBQSU5HUykpIHtcbiAgICBjb25zdCB2YXJpYWJsZVBhdHRlcm4gPSBuZXcgUmVnRXhwKGBcXFxcWyR7dmFyaWFibGVOYW1lfVxcXFxdYCwgJ2cnKTtcbiAgICBjb25zdCB2YWx1ZSA9IChzdGF0cyBhcyBhbnkpW2ZpZWxkTmFtZV07XG4gICAgXG4gICAgLy8gSGFuZGxlIG1pc3Npbmcgb3IgdW5kZWZpbmVkIHZhbHVlc1xuICAgIGNvbnN0IGFjdHVhbFZhbHVlID0gKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpID8gdmFsdWUgOiAwO1xuICAgIFxuICAgIHByb2Nlc3NlZEZvcm11bGEgPSBwcm9jZXNzZWRGb3JtdWxhLnJlcGxhY2UodmFyaWFibGVQYXR0ZXJuLCBhY3R1YWxWYWx1ZS50b1N0cmluZygpKTtcbiAgfVxuICBcbiAgcmV0dXJuIHByb2Nlc3NlZEZvcm11bGE7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIG1hdGhlbWF0aWNhbCBmdW5jdGlvbnMgaW4gYSBmb3JtdWxhIHN0cmluZ1xuICogUmVwbGFjZXMgZnVuY3Rpb24gY2FsbHMgbGlrZSBNQVgoMSwyLDMpIHdpdGggdGhlaXIgZXZhbHVhdGVkIHJlc3VsdHNcbiAqIEBwYXJhbSBmb3JtdWxhIC0gRm9ybXVsYSBzdHJpbmcgcG90ZW50aWFsbHkgY29udGFpbmluZyBmdW5jdGlvbiBjYWxsc1xuICogQHJldHVybnMgRm9ybXVsYSBzdHJpbmcgd2l0aCBmdW5jdGlvbnMgZXZhbHVhdGVkXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NNYXRoRnVuY3Rpb25zKGZvcm11bGE6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBwcm9jZXNzZWRGb3JtdWxhID0gZm9ybXVsYTtcbiAgXG4gIC8vIFByb2Nlc3MgZWFjaCBhdmFpbGFibGUgbWF0aCBmdW5jdGlvblxuICBmb3IgKGNvbnN0IFtmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uSW1wbF0gb2YgT2JqZWN0LmVudHJpZXMoTUFUSF9GVU5DVElPTlMpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25SZWdleCA9IG5ldyBSZWdFeHAoYCR7ZnVuY3Rpb25OYW1lfVxcXFwoKFteKV0rKVxcXFwpYCwgJ2cnKTtcbiAgICBcbiAgICBwcm9jZXNzZWRGb3JtdWxhID0gcHJvY2Vzc2VkRm9ybXVsYS5yZXBsYWNlKGZ1bmN0aW9uUmVnZXgsIChtYXRjaCwgYXJnc1N0cmluZykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUGFyc2UgYXJndW1lbnRzIChoYW5kbGUgbmVzdGVkIGV4cHJlc3Npb25zIGJ5IGV2YWx1YXRpbmcgdGhlbSBmaXJzdClcbiAgICAgICAgY29uc3QgYXJncyA9IGFyZ3NTdHJpbmcuc3BsaXQoJywnKS5tYXAoKGFyZzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHJpbW1lZEFyZyA9IGFyZy50cmltKCk7XG4gICAgICAgICAgLy8gSWYgYXJndW1lbnQgY29udGFpbnMgb3BlcmF0b3JzLCBldmFsdWF0ZSBpdCBmaXJzdFxuICAgICAgICAgIGlmICgvWytcXC0qLygpXS8udGVzdCh0cmltbWVkQXJnKSkge1xuICAgICAgICAgICAgY29uc3QgYXJnUmVzdWx0ID0gZXZhbHVhdGVTaW1wbGVFeHByZXNzaW9uKHRyaW1tZWRBcmcpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmdSZXN1bHQgPT09ICdudW1iZXInID8gYXJnUmVzdWx0IDogMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodHJpbW1lZEFyZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBwYXJzZWQgYXJndW1lbnRzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmN0aW9uSW1wbCguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gJ05BJyA/ICdOYU4nIDogcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICdOYU4nOyAvLyBSZXR1cm4gTmFOIGZvciBhbnkgZnVuY3Rpb24gZXZhbHVhdGlvbiBlcnJvcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgcmV0dXJuIHByb2Nlc3NlZEZvcm11bGE7XG59XG5cbi8qKlxuICogU2FmZWx5IGV2YWx1YXRlcyBhIHNpbXBsZSBtYXRoZW1hdGljYWwgZXhwcmVzc2lvblxuICogSGFuZGxlcyBiYXNpYyBhcml0aG1ldGljIG9wZXJhdGlvbnMgd2l0aCBkaXZpc2lvbiBieSB6ZXJvIHByb3RlY3Rpb25cbiAqIEBwYXJhbSBleHByZXNzaW9uIC0gTWF0aGVtYXRpY2FsIGV4cHJlc3Npb24gdG8gZXZhbHVhdGVcbiAqIEByZXR1cm5zIE51bWVyaWMgcmVzdWx0IG9yICdOQScgZm9yIGVycm9yc1xuICovXG5mdW5jdGlvbiBldmFsdWF0ZVNpbXBsZUV4cHJlc3Npb24oZXhwcmVzc2lvbjogc3RyaW5nKTogbnVtYmVyIHwgJ05BJyB7XG4gIHRyeSB7XG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VcbiAgICBjb25zdCBjbGVhbkV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBkaXZpc2lvbiBieSB6ZXJvXG4gICAgaWYgKC9cXC9cXHMqMCg/IVxcZCkvLnRlc3QoY2xlYW5FeHByZXNzaW9uKSkge1xuICAgICAgcmV0dXJuICdOQSc7XG4gICAgfVxuICAgIFxuICAgIC8vIFVzZSBGdW5jdGlvbiBjb25zdHJ1Y3RvciBmb3Igc2FmZSBldmFsdWF0aW9uIChtb3JlIHNlY3VyZSB0aGFuIGV2YWwpXG4gICAgLy8gVGhpcyBvbmx5IGFsbG93cyBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucywgbm8gYWNjZXNzIHRvIGdsb2JhbCBzY29wZVxuICAgIGNvbnN0IHNhZmVFdmFsID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGNsZWFuRXhwcmVzc2lvbik7XG4gICAgY29uc3QgcmVzdWx0ID0gc2FmZUV2YWwoKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgaW52YWxpZCByZXN1bHRzXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdudW1iZXInIHx8IGlzTmFOKHJlc3VsdCkgfHwgIWlzRmluaXRlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiAnTkEnO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnTkEnO1xuICB9XG59XG5cbi8qKlxuICogTWFpbiBmdW5jdGlvbiB0byBldmFsdWF0ZSBhIGZvcm11bGEgYWdhaW5zdCBwcm9qZWN0IHN0YXRpc3RpY3NcbiAqIEhhbmRsZXMgdmFyaWFibGUgc3Vic3RpdHV0aW9uLCBmdW5jdGlvbiBwcm9jZXNzaW5nLCBhbmQgc2FmZSBldmFsdWF0aW9uXG4gKiBAcGFyYW0gZm9ybXVsYSAtIFRoZSBmb3JtdWxhIHN0cmluZyB0byBldmFsdWF0ZVxuICogQHBhcmFtIHN0YXRzIC0gUHJvamVjdCBzdGF0aXN0aWNzIGZvciB2YXJpYWJsZSB2YWx1ZXNcbiAqIEByZXR1cm5zIE51bWVyaWMgcmVzdWx0IG9yICdOQScgZm9yIGVycm9ycy9pbnZhbGlkIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlRm9ybXVsYShmb3JtdWxhOiBzdHJpbmcsIHN0YXRzOiBQcm9qZWN0U3RhdHMpOiBudW1iZXIgfCAnTkEnIHtcbiAgdHJ5IHtcbiAgICAvLyBTdGVwIDE6IFN1YnN0aXR1dGUgdmFyaWFibGVzIHdpdGggYWN0dWFsIHZhbHVlc1xuICAgIGNvbnN0IGZvcm11bGFXaXRoVmFsdWVzID0gc3Vic3RpdHV0ZVZhcmlhYmxlcyhmb3JtdWxhLCBzdGF0cyk7XG4gICAgXG4gICAgLy8gU3RlcCAyOiBQcm9jZXNzIG1hdGhlbWF0aWNhbCBmdW5jdGlvbnNcbiAgICBjb25zdCBmb3JtdWxhV2l0aEZ1bmN0aW9ucyA9IHByb2Nlc3NNYXRoRnVuY3Rpb25zKGZvcm11bGFXaXRoVmFsdWVzKTtcbiAgICBcbiAgICAvLyBTdGVwIDM6IEV2YWx1YXRlIHRoZSBmaW5hbCBtYXRoZW1hdGljYWwgZXhwcmVzc2lvblxuICAgIGNvbnN0IHJlc3VsdCA9IGV2YWx1YXRlU2ltcGxlRXhwcmVzc2lvbihmb3JtdWxhV2l0aEZ1bmN0aW9ucyk7XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGb3JtdWxhIGV2YWx1YXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiAnTkEnO1xuICB9XG59XG5cbi8qKlxuICogQmF0Y2ggZXZhbHVhdGVzIG11bHRpcGxlIGZvcm11bGFzIGFnYWluc3QgdGhlIHNhbWUgcHJvamVjdCBzdGF0aXN0aWNzXG4gKiBNb3JlIGVmZmljaWVudCB0aGFuIGNhbGxpbmcgZXZhbHVhdGVGb3JtdWxhIG11bHRpcGxlIHRpbWVzXG4gKiBAcGFyYW0gZm9ybXVsYXMgLSBBcnJheSBvZiBmb3JtdWxhIHN0cmluZ3MgdG8gZXZhbHVhdGVcbiAqIEBwYXJhbSBzdGF0cyAtIFByb2plY3Qgc3RhdGlzdGljcyBmb3IgdmFyaWFibGUgdmFsdWVzICBcbiAqIEByZXR1cm5zIEFycmF5IG9mIHJlc3VsdHMgY29ycmVzcG9uZGluZyB0byBpbnB1dCBmb3JtdWxhc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVGb3JtdWxhc0JhdGNoKFxuICBmb3JtdWxhczogc3RyaW5nW10sIFxuICBzdGF0czogUHJvamVjdFN0YXRzXG4pOiAobnVtYmVyIHwgJ05BJylbXSB7XG4gIHJldHVybiBmb3JtdWxhcy5tYXAoZm9ybXVsYSA9PiBldmFsdWF0ZUZvcm11bGEoZm9ybXVsYSwgc3RhdHMpKTtcbn1cblxuLyoqXG4gKiBHZXRzIGFsbCBhdmFpbGFibGUgdmFyaWFibGVzIHdpdGggdGhlaXIgZGVzY3JpcHRpb25zXG4gKiBVc2VmdWwgZm9yIGJ1aWxkaW5nIHZhcmlhYmxlIHBpY2tlciBVSXNcbiAqIEByZXR1cm5zIEFycmF5IG9mIGF2YWlsYWJsZSB2YXJpYWJsZXMgd2l0aCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlVmFyaWFibGVzKCkge1xuICByZXR1cm4gQVZBSUxBQkxFX1ZBUklBQkxFUztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzcGVjaWZpYyB2YXJpYWJsZSBleGlzdHMgYW5kIGlzIHZhbGlkXG4gKiBAcGFyYW0gdmFyaWFibGVOYW1lIC0gTmFtZSBvZiB2YXJpYWJsZSB0byBjaGVjayAoZS5nLiwgXCJJTkRPT1JcIiwgXCJGRU1BTEVcIilcbiAqIEByZXR1cm5zIEJvb2xlYW4gaW5kaWNhdGluZyBpZiB2YXJpYWJsZSBpcyB2YWxpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFZhcmlhYmxlKHZhcmlhYmxlTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBWQVJJQUJMRV9NQVBQSU5HUy5oYXNPd25Qcm9wZXJ0eSh2YXJpYWJsZU5hbWUpO1xufVxuXG4vKipcbiAqIEdldHMgZXhhbXBsZSB1c2FnZSBmb3IgYSBzcGVjaWZpYyB2YXJpYWJsZVxuICogQHBhcmFtIHZhcmlhYmxlTmFtZSAtIE5hbWUgb2YgdmFyaWFibGUgdG8gZ2V0IGV4YW1wbGUgZm9yXG4gKiBAcmV0dXJucyBFeGFtcGxlIGZvcm11bGEgdXNpbmcgdGhlIHZhcmlhYmxlLCBvciBudWxsIGlmIHZhcmlhYmxlIGlzIGludmFsaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhcmlhYmxlRXhhbXBsZSh2YXJpYWJsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCB2YXJpYWJsZSA9IEFWQUlMQUJMRV9WQVJJQUJMRVMuZmluZCh2ID0+IHYubmFtZSA9PT0gdmFyaWFibGVOYW1lKTtcbiAgcmV0dXJuIHZhcmlhYmxlID8gdmFyaWFibGUuZXhhbXBsZVVzYWdlIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUZXN0IHV0aWxpdHkgZnVuY3Rpb24gZm9yIGRldmVsb3BtZW50IGFuZCBkZWJ1Z2dpbmdcbiAqIEV2YWx1YXRlcyBhIGZvcm11bGEgYWdhaW5zdCBzYW1wbGUgdGVzdCBkYXRhXG4gKiBAcGFyYW0gZm9ybXVsYSAtIEZvcm11bGEgdG8gdGVzdFxuICogQHJldHVybnMgVGVzdCByZXN1bHQgd2l0aCBzYW1wbGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVzdEZvcm11bGEoZm9ybXVsYTogc3RyaW5nKTogeyByZXN1bHQ6IG51bWJlciB8ICdOQSc7IHNhbXBsZURhdGE6IFByb2plY3RTdGF0cyB9IHtcbiAgY29uc3Qgc2FtcGxlRGF0YTogUHJvamVjdFN0YXRzID0ge1xuICAgIHJlbW90ZUltYWdlczogMTAsIGhvc3Rlc3NJbWFnZXM6IDI1LCBzZWxmaWVzOiAxNSxcbiAgICBpbmRvb3I6IDUwLCBvdXRkb29yOiAzMCwgc3RhZGl1bTogMjAwLFxuICAgIGZlbWFsZTogMTIwLCBtYWxlOiAxNjAsXG4gICAgZ2VuQWxwaGE6IDIwLCBnZW5ZWjogMTAwLCBnZW5YOiA4MCwgYm9vbWVyOiA4MCxcbiAgICBtZXJjaGVkOiA0MCwgamVyc2V5OiAxNSwgc2NhcmY6IDgsIGZsYWdzOiAxMiwgYmFzZWJhbGxDYXA6IDUsIG90aGVyOiAzLFxuICAgIGFwcHJvdmVkSW1hZ2VzOiA0NSwgcmVqZWN0ZWRJbWFnZXM6IDUsXG4gICAgdmlzaXRRckNvZGU6IDMwLCB2aXNpdFNob3J0VXJsOiAyMCwgdmlzaXRXZWI6IDEwMCxcbiAgICB2aXNpdEZhY2Vib29rOiAyNSwgdmlzaXRJbnN0YWdyYW06IDQwLCB2aXNpdFlvdXR1YmU6IDE1LFxuICAgIHZpc2l0VGlrdG9rOiAzNSwgdmlzaXRYOiAxMCwgdmlzaXRUcnVzdHBpbG90OiA1LFxuICAgIGV2ZW50QXR0ZW5kZWVzOiAxMDAwLCBldmVudFRpY2tldFB1cmNoYXNlczogODUwLFxuICAgIGV2ZW50UmVzdWx0SG9tZTogMiwgZXZlbnRSZXN1bHRWaXNpdG9yOiAxLFxuICAgIGV2ZW50VmFsdWVQcm9wb3NpdGlvblZpc2l0ZWQ6IDc1LCBldmVudFZhbHVlUHJvcG9zaXRpb25QdXJjaGFzZXM6IDEyXG4gIH07XG4gIFxuICBjb25zdCByZXN1bHQgPSBldmFsdWF0ZUZvcm11bGEoZm9ybXVsYSwgc2FtcGxlRGF0YSk7XG4gIHJldHVybiB7IHJlc3VsdCwgc2FtcGxlRGF0YSB9O1xufVxuIl0sIm5hbWVzIjpbIkFWQUlMQUJMRV9WQVJJQUJMRVMiLCJWQVJJQUJMRV9NQVBQSU5HUyIsIk1BVEhfRlVOQ1RJT05TIiwiTUFYIiwiYXJncyIsImxlbmd0aCIsInZhbGlkQXJncyIsImZpbHRlciIsImFyZyIsImlzTmFOIiwiTWF0aCIsIm1heCIsIk1JTiIsIm1pbiIsIlJPVU5EIiwidmFsdWUiLCJyb3VuZCIsIkFCUyIsImFicyIsImV4dHJhY3RWYXJpYWJsZXNGcm9tRm9ybXVsYSIsImZvcm11bGEiLCJ2YXJpYWJsZVJlZ2V4IiwidmFyaWFibGVzIiwibWF0Y2giLCJleGVjIiwidmFyaWFibGVOYW1lIiwiaW5jbHVkZXMiLCJwdXNoIiwidmFsaWRhdGVGb3JtdWxhIiwidXNlZFZhcmlhYmxlcyIsImludmFsaWRWYXJpYWJsZXMiLCJ2YXJpYWJsZSIsImhhc093blByb3BlcnR5IiwiaXNWYWxpZCIsImVycm9yIiwiam9pbiIsIm9wZW5QYXJlbnMiLCJjaGFyIiwidGVzdFN0YXRzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJ2YWx1ZXMiLCJtYXAiLCJmaWVsZCIsInRlc3RSZXN1bHQiLCJldmFsdWF0ZUZvcm11bGEiLCJldmFsdWF0ZWRSZXN1bHQiLCJFcnJvciIsIm1lc3NhZ2UiLCJzdWJzdGl0dXRlVmFyaWFibGVzIiwic3RhdHMiLCJwcm9jZXNzZWRGb3JtdWxhIiwiZmllbGROYW1lIiwiZW50cmllcyIsInZhcmlhYmxlUGF0dGVybiIsIlJlZ0V4cCIsImFjdHVhbFZhbHVlIiwidW5kZWZpbmVkIiwicmVwbGFjZSIsInRvU3RyaW5nIiwicHJvY2Vzc01hdGhGdW5jdGlvbnMiLCJmdW5jdGlvbk5hbWUiLCJmdW5jdGlvbkltcGwiLCJmdW5jdGlvblJlZ2V4IiwiYXJnc1N0cmluZyIsInNwbGl0IiwidHJpbW1lZEFyZyIsInRyaW0iLCJ0ZXN0IiwiYXJnUmVzdWx0IiwiZXZhbHVhdGVTaW1wbGVFeHByZXNzaW9uIiwicGFyc2VGbG9hdCIsInJlc3VsdCIsImV4cHJlc3Npb24iLCJjbGVhbkV4cHJlc3Npb24iLCJzYWZlRXZhbCIsIkZ1bmN0aW9uIiwiaXNGaW5pdGUiLCJmb3JtdWxhV2l0aFZhbHVlcyIsImZvcm11bGFXaXRoRnVuY3Rpb25zIiwiY29uc29sZSIsImV2YWx1YXRlRm9ybXVsYXNCYXRjaCIsImZvcm11bGFzIiwiZ2V0QXZhaWxhYmxlVmFyaWFibGVzIiwiaXNWYWxpZFZhcmlhYmxlIiwiZ2V0VmFyaWFibGVFeGFtcGxlIiwiZmluZCIsInYiLCJuYW1lIiwiZXhhbXBsZVVzYWdlIiwidGVzdEZvcm11bGEiLCJzYW1wbGVEYXRhIiwicmVtb3RlSW1hZ2VzIiwiaG9zdGVzc0ltYWdlcyIsInNlbGZpZXMiLCJpbmRvb3IiLCJvdXRkb29yIiwic3RhZGl1bSIsImZlbWFsZSIsIm1hbGUiLCJnZW5BbHBoYSIsImdlbllaIiwiZ2VuWCIsImJvb21lciIsIm1lcmNoZWQiLCJqZXJzZXkiLCJzY2FyZiIsImZsYWdzIiwiYmFzZWJhbGxDYXAiLCJvdGhlciIsImFwcHJvdmVkSW1hZ2VzIiwicmVqZWN0ZWRJbWFnZXMiLCJ2aXNpdFFyQ29kZSIsInZpc2l0U2hvcnRVcmwiLCJ2aXNpdFdlYiIsInZpc2l0RmFjZWJvb2siLCJ2aXNpdEluc3RhZ3JhbSIsInZpc2l0WW91dHViZSIsInZpc2l0VGlrdG9rIiwidmlzaXRYIiwidmlzaXRUcnVzdHBpbG90IiwiZXZlbnRBdHRlbmRlZXMiLCJldmVudFRpY2tldFB1cmNoYXNlcyIsImV2ZW50UmVzdWx0SG9tZSIsImV2ZW50UmVzdWx0VmlzaXRvciIsImV2ZW50VmFsdWVQcm9wb3NpdGlvblZpc2l0ZWQiLCJldmVudFZhbHVlUHJvcG9zaXRpb25QdXJjaGFzZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/formulaEngine.ts\n"));

/***/ })

});